name: 'Deploy Helix World'
description: 'Uploads a Helix automatically'
inputs:
  access_token:
    description: 'Access token for authentication. Can be generated at Account -> Settings'
    required: true
    type: string
  world_name:
    description: 'Name of the world to upload. Make sure you already have this world created'
    required: true
    type: string
  packages_path:
    description: 'Path to the packages directory. Defaults to the current directory'
    required: false
    type: string
  private_ssh_key:
    description: 'Private SSH key for authentication in github'
    required: false
    type: string

outputs: {}
runs:
  using: 'composite'
  steps:
    - name: Set up Git for submodule access
      shell: bash
      env:
        PRIVATE_SSH_KEY: ${{ inputs.private_ssh_key }}
      run: |
        if [ -z "$PRIVATE_SSH_KEY" ]; then
          echo "Skipping private repository setup"
        else
          echo "Configuring git for private github repositories"
          eval `ssh-agent -s`
          ssh-add - <<< "$PRIVATE_SSH_KEY"
        fi

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: true
        fetch-depth: 1 

    - name: Update Submodules
      shell: bash
      run: |
         git submodule sync
         git submodule update --init --recursive --remote

    - name: Install jq
      shell: bash
      run: sudo apt-get install -y jq

    - name: Remove .files
      shell: bash
      run: |
        rm -rf .git
        rm -rf .github


    - name: Zip repository
      shell: bash
      env:
        PACKAGES_PATH: ${{ inputs.packages_path || '.' }}
      run: |
        ORIGINAL_CWD=$(pwd)
        cd "$PACKAGES_PATH"
        if [ -d "Packages" ]; then
          zip -r main.zip Packages
          mv main.zip "$ORIGINAL_CWD" || true
        else
          echo "Directory 'Packages' does not exist in $PACKAGES_PATH"
          exit 1
        fi

    - name: Get World ID
      id: get_world_id
      shell: bash
      env:
        WORLD_NAME: ${{ inputs.world_name }}
        ACCESS_TOKEN: ${{ inputs.access_token }}
      run: |
        response=$(curl --location "https://api.helixgame.com/v1/world/${WORLD_NAME}" --header "Token: ${ACCESS_TOKEN}")
        echo "world_id=$(echo $response | jq -r '.payload.id')" >> $GITHUB_OUTPUT

    - name: Request presigned URL
      id: presigned_url
      shell: bash
      env:
        ACCESS_TOKEN: ${{ inputs.access_token }}
        WORLD_ID: ${{ steps.get_world_id.outputs.world_id }}
      run: |
        response=$(curl --location "https://api.helixgame.com/v1/world/upload/packages/${WORLD_ID}" --header "Token: ${ACCESS_TOKEN}")
        code=$(echo $response | jq -r '.code')
        message=$(echo $response | jq -r '.message')
        if [ "$code" != "0" ]; then
          if [ "$message" == "world corrupted" ]; then
            echo "Error: Make sure you've created this world on the HELIX Hub first: https://hub.helixgame.com/creations/worlds"
          else
            echo "Error: Server returned error code $code with message '$message'"
          fi
          exit 1
        fi
        echo "upload_url=$(echo $response | jq -r '.payload.upload_url')" >> $GITHUB_OUTPUT
        echo "world_url=$(echo $response | jq -r '.payload.world_url')" >> $GITHUB_OUTPUT

    - name: Upload zip file
      shell: bash
      env:
        UPLOAD_URL: ${{ steps.presigned_url.outputs.upload_url }}
      run: |
        curl --location --request PUT "${UPLOAD_URL}" \
          --header "Content-Type: application/zip" \
          --data-binary "@main.zip"

    - name: Finish upload
      shell: bash
      env:
        ACCESS_TOKEN: ${{ inputs.access_token }}
        WORLD_URL: ${{ steps.presigned_url.outputs.world_url }}
        WORLD_ID: ${{ steps.get_world_id.outputs.world_id }}
      run: |
        curl --location "https://api.helixgame.com/v1/world/upload/packages/finish?url=${WORLD_URL}&world_id=${WORLD_ID}" --header "Token: ${ACCESS_TOKEN}"

